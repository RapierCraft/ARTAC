"""
ARTAC Code Artifact Manager
Manages agent-generated code artifacts, file versioning, and user access
"""

import asyncio
import json
import os
import shutil
import uuid
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Union
import hashlib
import zipfile
from dataclasses import dataclass, asdict
from enum import Enum

from core.config import settings
from core.logging import get_logger
from services.project_workspace_manager import project_workspace_manager

logger = get_logger(__name__)


class ArtifactType(str, Enum):
    SOURCE_CODE = "source_code"
    CONFIGURATION = "configuration"
    DOCUMENTATION = "documentation"
    TEST_FILE = "test_file"
    ASSET = "asset"
    SCRIPT = "script"
    SCHEMA = "schema"
    LOG = "log"


class ArtifactStatus(str, Enum):
    DRAFT = "draft"
    REVIEW_PENDING = "review_pending"
    APPROVED = "approved"
    DEPLOYED = "deployed"
    ARCHIVED = "archived"


@dataclass
class CodeArtifact:
    """Represents a single code artifact created by an agent"""
    id: str
    project_id: str
    agent_id: str
    agent_name: str
    file_path: str  # Relative path within project
    file_name: str
    artifact_type: ArtifactType
    content: str
    content_hash: str
    status: ArtifactStatus
    version: int
    parent_version: Optional[str]  # For tracking changes
    commit_sha: Optional[str]
    task_id: Optional[str]
    description: str
    metadata: Dict[str, Any]
    created_at: datetime
    updated_at: datetime
    reviewed_by: Optional[str] = None
    review_notes: Optional[str] = None


@dataclass
class FileVersion:
    """Represents a version of a file"""
    version_id: str
    artifact_id: str
    version_number: int
    content: str
    content_hash: str
    changes_summary: str
    created_by: str
    created_at: datetime
    commit_sha: Optional[str] = None


@dataclass
class CodebaseSnapshot:
    """Represents a snapshot of the entire codebase at a point in time"""
    snapshot_id: str
    project_id: str
    snapshot_name: str
    description: str
    artifacts: List[str]  # List of artifact IDs included
    commit_sha: str
    created_by: str
    created_at: datetime
    tags: List[str] = None


class CodeArtifactManager:
    """Manages all code artifacts generated by agents"""
    
    def __init__(self):
        self.artifacts: Dict[str, CodeArtifact] = {}
        self.file_versions: Dict[str, List[FileVersion]] = {}  # file_path -> versions
        self.snapshots: Dict[str, CodebaseSnapshot] = {}
        self.artifact_index: Dict[str, List[str]] = {}  # project_id -> artifact_ids
        
        # Storage paths
        self.base_path = os.path.join(settings.WORKSPACE_ROOT, "artifacts")
        self.versions_path = os.path.join(self.base_path, "versions")
        self.snapshots_path = os.path.join(self.base_path, "snapshots")
        self.metadata_path = os.path.join(self.base_path, "metadata")
        
        # Ensure directories exist
        os.makedirs(self.base_path, exist_ok=True)
        os.makedirs(self.versions_path, exist_ok=True)
        os.makedirs(self.snapshots_path, exist_ok=True)
        os.makedirs(self.metadata_path, exist_ok=True)
    
    async def create_artifact(
        self,
        project_id: str,
        agent_id: str,
        agent_name: str,
        file_path: str,
        content: str,
        artifact_type: ArtifactType,
        task_id: Optional[str] = None,
        description: str = "",
        metadata: Dict[str, Any] = None
    ) -> str:
        """Create a new code artifact"""
        try:
            artifact_id = f"art_{uuid.uuid4().hex[:12]}"
            file_name = os.path.basename(file_path)
            content_hash = hashlib.sha256(content.encode()).hexdigest()
            
            # Check if this file already exists and get version number
            existing_versions = self.file_versions.get(file_path, [])
            version = len(existing_versions) + 1
            parent_version = existing_versions[-1].version_id if existing_versions else None
            
            artifact = CodeArtifact(
                id=artifact_id,
                project_id=project_id,
                agent_id=agent_id,
                agent_name=agent_name,
                file_path=file_path,
                file_name=file_name,
                artifact_type=artifact_type,
                content=content,
                content_hash=content_hash,
                status=ArtifactStatus.DRAFT,
                version=version,
                parent_version=parent_version,
                commit_sha=None,
                task_id=task_id,
                description=description,
                metadata=metadata or {},
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            
            # Store artifact
            self.artifacts[artifact_id] = artifact
            
            # Update project index
            if project_id not in self.artifact_index:
                self.artifact_index[project_id] = []
            self.artifact_index[project_id].append(artifact_id)
            
            # Create file version
            await self._create_file_version(artifact)
            
            # Save to filesystem
            await self._save_artifact_to_filesystem(artifact)
            
            # Save to project workspace
            await self._update_project_workspace(artifact)
            
            logger.log_system_event("code_artifact_created", {
                "artifact_id": artifact_id,
                "project_id": project_id,
                "agent_id": agent_id,
                "file_path": file_path,
                "artifact_type": artifact_type.value,
                "version": version
            })
            
            return artifact_id
            
        except Exception as e:
            logger.log_error(e, {
                "action": "create_artifact",
                "project_id": project_id,
                "agent_id": agent_id,
                "file_path": file_path
            })
            raise
    
    async def _create_file_version(self, artifact: CodeArtifact):
        """Create a new file version entry"""
        version_id = f"ver_{uuid.uuid4().hex[:8]}"
        
        # Determine changes summary
        changes_summary = "Initial version"
        if artifact.parent_version:
            changes_summary = f"Updated by {artifact.agent_name}"
        
        version = FileVersion(
            version_id=version_id,
            artifact_id=artifact.id,
            version_number=artifact.version,
            content=artifact.content,
            content_hash=artifact.content_hash,
            changes_summary=changes_summary,
            created_by=artifact.agent_id,
            created_at=artifact.created_at
        )
        
        # Store version
        if artifact.file_path not in self.file_versions:
            self.file_versions[artifact.file_path] = []
        self.file_versions[artifact.file_path].append(version)
    
    async def _save_artifact_to_filesystem(self, artifact: CodeArtifact):
        """Save artifact content to filesystem"""
        # Create artifact-specific directory
        artifact_dir = os.path.join(self.versions_path, artifact.project_id, artifact.id)
        os.makedirs(artifact_dir, exist_ok=True)
        
        # Save content
        content_file = os.path.join(artifact_dir, "content")
        with open(content_file, 'w', encoding='utf-8') as f:
            f.write(artifact.content)
        
        # Save metadata
        metadata_file = os.path.join(artifact_dir, "metadata.json")
        with open(metadata_file, 'w') as f:
            json.dump(asdict(artifact), f, indent=2, default=str)
    
    async def _update_project_workspace(self, artifact: CodeArtifact):
        """Update the project workspace with the new artifact"""
        try:
            workspace = await project_workspace_manager.get_project(artifact.project_id)
            if workspace:
                agent_workspace = os.path.join(workspace.agents_path, artifact.agent_id)
                if os.path.exists(agent_workspace):
                    # Write file to agent's workspace
                    full_file_path = os.path.join(agent_workspace, artifact.file_path)
                    os.makedirs(os.path.dirname(full_file_path), exist_ok=True)
                    
                    with open(full_file_path, 'w', encoding='utf-8') as f:
                        f.write(artifact.content)
        except Exception as e:
            logger.log_error(e, {
                "action": "update_project_workspace",
                "artifact_id": artifact.id,
                "project_id": artifact.project_id
            })
    
    async def get_artifact(self, artifact_id: str) -> Optional[CodeArtifact]:
        """Get an artifact by ID"""
        return self.artifacts.get(artifact_id)
    
    async def get_project_artifacts(self, project_id: str) -> List[CodeArtifact]:
        """Get all artifacts for a project"""
        artifact_ids = self.artifact_index.get(project_id, [])
        return [self.artifacts[aid] for aid in artifact_ids if aid in self.artifacts]
    
    async def get_file_versions(self, project_id: str, file_path: str) -> List[FileVersion]:
        """Get all versions of a specific file"""
        return self.file_versions.get(file_path, [])
    
    async def get_agent_artifacts(self, agent_id: str) -> List[CodeArtifact]:
        """Get all artifacts created by a specific agent"""
        return [
            artifact for artifact in self.artifacts.values()
            if artifact.agent_id == agent_id
        ]
    
    async def update_artifact_status(
        self,
        artifact_id: str,
        new_status: ArtifactStatus,
        reviewed_by: Optional[str] = None,
        review_notes: Optional[str] = None
    ) -> bool:
        """Update artifact status (e.g., approve for deployment)"""
        try:
            if artifact_id not in self.artifacts:
                return False
            
            artifact = self.artifacts[artifact_id]
            artifact.status = new_status
            artifact.updated_at = datetime.utcnow()
            
            if reviewed_by:
                artifact.reviewed_by = reviewed_by
            if review_notes:
                artifact.review_notes = review_notes
            
            # Re-save to filesystem
            await self._save_artifact_to_filesystem(artifact)
            
            logger.log_system_event("artifact_status_updated", {
                "artifact_id": artifact_id,
                "new_status": new_status.value,
                "reviewed_by": reviewed_by
            })
            
            return True
            
        except Exception as e:
            logger.log_error(e, {
                "action": "update_artifact_status",
                "artifact_id": artifact_id
            })
            return False
    
    async def create_codebase_snapshot(
        self,
        project_id: str,
        snapshot_name: str,
        description: str,
        created_by: str,
        commit_sha: str,
        tags: List[str] = None
    ) -> str:
        """Create a snapshot of the entire codebase"""
        try:
            snapshot_id = f"snap_{uuid.uuid4().hex[:8]}"
            
            # Get all approved artifacts for the project
            project_artifacts = await self.get_project_artifacts(project_id)
            approved_artifacts = [
                art.id for art in project_artifacts
                if art.status in [ArtifactStatus.APPROVED, ArtifactStatus.DEPLOYED]
            ]
            
            snapshot = CodebaseSnapshot(
                snapshot_id=snapshot_id,
                project_id=project_id,
                snapshot_name=snapshot_name,
                description=description,
                artifacts=approved_artifacts,
                commit_sha=commit_sha,
                created_by=created_by,
                created_at=datetime.utcnow(),
                tags=tags or []
            )
            
            self.snapshots[snapshot_id] = snapshot
            
            # Create snapshot archive
            await self._create_snapshot_archive(snapshot)
            
            logger.log_system_event("codebase_snapshot_created", {
                "snapshot_id": snapshot_id,
                "project_id": project_id,
                "artifacts_count": len(approved_artifacts)
            })
            
            return snapshot_id
            
        except Exception as e:
            logger.log_error(e, {
                "action": "create_codebase_snapshot",
                "project_id": project_id
            })
            raise
    
    async def _create_snapshot_archive(self, snapshot: CodebaseSnapshot):
        """Create a ZIP archive of the snapshot"""
        archive_path = os.path.join(self.snapshots_path, f"{snapshot.snapshot_id}.zip")
        
        with zipfile.ZipFile(archive_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for artifact_id in snapshot.artifacts:
                artifact = self.artifacts.get(artifact_id)
                if artifact:
                    # Add file to archive
                    zipf.writestr(artifact.file_path, artifact.content)
            
            # Add snapshot metadata
            zipf.writestr("snapshot_metadata.json", json.dumps(asdict(snapshot), indent=2, default=str))
    
    async def get_project_codebase_tree(self, project_id: str) -> Dict[str, Any]:
        """Get a tree structure of all project files"""
        artifacts = await self.get_project_artifacts(project_id)
        tree = {}
        
        for artifact in artifacts:
            path_parts = artifact.file_path.split('/')
            current_level = tree
            
            for i, part in enumerate(path_parts):
                if i == len(path_parts) - 1:  # It's a file
                    current_level[part] = {
                        "type": "file",
                        "artifact_id": artifact.id,
                        "agent_name": artifact.agent_name,
                        "status": artifact.status.value,
                        "updated_at": artifact.updated_at.isoformat(),
                        "version": artifact.version
                    }
                else:  # It's a directory
                    if part not in current_level:
                        current_level[part] = {"type": "directory"}
                    current_level = current_level[part]
        
        return tree
    
    async def get_artifact_content(self, artifact_id: str) -> Optional[str]:
        """Get the content of an artifact"""
        artifact = await self.get_artifact(artifact_id)
        return artifact.content if artifact else None
    
    async def search_artifacts(
        self,
        project_id: Optional[str] = None,
        agent_id: Optional[str] = None,
        artifact_type: Optional[ArtifactType] = None,
        status: Optional[ArtifactStatus] = None,
        search_term: Optional[str] = None
    ) -> List[CodeArtifact]:
        """Search artifacts with various filters"""
        results = list(self.artifacts.values())
        
        if project_id:
            results = [a for a in results if a.project_id == project_id]
        
        if agent_id:
            results = [a for a in results if a.agent_id == agent_id]
        
        if artifact_type:
            results = [a for a in results if a.artifact_type == artifact_type]
        
        if status:
            results = [a for a in results if a.status == status]
        
        if search_term:
            search_term = search_term.lower()
            results = [
                a for a in results
                if search_term in a.file_name.lower() or
                   search_term in a.description.lower() or
                   search_term in a.content.lower()
            ]
        
        return sorted(results, key=lambda x: x.updated_at, reverse=True)


# Global instance
code_artifact_manager = CodeArtifactManager()